{
  "examples.starter.title": "Ćwiczenia",
  "examples.starter.description": "Nadszedł czas na wykonanie kilku ćwiczeń, aby utrwalić to, czego się nauczyliśmy.",

  "examples.finish.title": "Koniec ćwiczeń!",
  "examples.finish.description": " ",

  "steps.starter.title": "Wstęp",
  "steps.starter.description": "Regex to skrót od `Regular Expression` (wyrażenie regularne). Pomaga dopasować, znaleźć lub zarządzać tekstem. Aby przejść do kolejnej sekcji i by uzyskać bardziej szczegółowy opis, wpisz `OK` w polu Regex.",

  "steps.whatIsRegex.title": "Czym jest wyrażenie regularne `Regex`?",
  "steps.whatIsRegex.description": "Wyrażenia regularne to ciągi znaków, które określaja wzorzec wyszukiwania. Ich skrótowym określeniem jest `Regex` lub `Regexp`. W szczególności wykorzystuje się je do wyszukiwania lub zamiany słów w tekstach. Ponadto, dzięki nim możemy sprawdzić, czy tekst spełnia określone przez nas zasady.\\n\\n Na przykład, przyjmijmy, że masz listę nazw plików i chcesz znaleźć tylko pliki o rozszerzeniu `pdf`. Wpisując wyrażenie `^\\w+\\.pdf$` osiągniesz zamierzony efekt. Znaczenie poszczególnych elementów tego wyrażenia regularnego stanie się dla Ciebie bardziej jasne wraz z kolejnymi sekcjami tego samouczka.",

  "steps.basicMatchers.title": "Podstawowe dopasowania",
  "steps.basicMatchers.description": "Znak lub słowo, które chcemy znaleźć, wpisujemy wprost. Jest to podobne do normalnego procesu wyszukiwania. Na przykład, aby znaleźć w tekście słowo `curious`, wpisz je tak samo.",

  "steps.dotCharacter.title": "Kropka `.`: dowolny znak",
  "steps.dotCharacter.description": "Kropka `.` umożliwia wybranie dowolnego znaku, w tym znaków specjalnych i spacji. Aby kontynuować, wpisz kropkę `.` w polu Regex.",

  "steps.characterSet.title": "Zbiór znaków `[abc]`",
  "steps.characterSet.description": "Jeśli w danym wyraze jeden ze znaków może być różnymi znakami, zapisujemy to stosując nawiasy kwadratowe `[]`, a w nim wszystkie alternatywy znaków. Na przykład, aby napisać wyrażenie, które może znaleźć wszystkie słowa w poniższym tekście, wpisz wewnątrz nawiasów kwadratowych `[]` kolejno litery `a`, `e`, `i`, `o`, `u`.",

  "steps.negatedCharacterSet.title": "Negacja zbioru znaków `[^abc]`",
  "steps.negatedCharacterSet.description": "Aby znaleźć wszystkie słowa w poniższym tekście, z wyjątkiem `ber` i `bor`, wewnątrz nawiasów kwadratowych `[]` po znaku `^` wpisz kolejno litery `e` i `o`.",

  "steps.range.title": "Zakres liter `[a-z]`",
  "steps.range.description": "Aby znaleźć litery w określonym zakresie, w nawiasach kwadratowych `[]` podaje się literę początkową i końcową oddzielone myślnikiem `-`. Wielkość liter ma znaczenie. Wpisz wyrażenie, które dopasuje wszystkie małe litery między `e` i `o`, włączając w to te litery.",

  "steps.rangeNumber.title": "Zakres cyfry `[0-9]`",
  "steps.rangeNumber.description": "Aby znaleźć cyfry w określonym zakresie, w nawiasach kwadratowych `[]` podaje się początkową i końcową cyfrę oddzielone myślnikiem `-`. Wpisz wyrażenie, które dopasuje wszystkie cyfry między `3` i `6`, włączając w to te cyfry.",

  "examples.basicMatchers.title": "Ćwiczenie: podstawowe dopasowanie",
  "examples.basicMatchers.description": "Napisz wyrażenie, które dopasuje w tekście słowo `of`.",

  "examples.dotCharacter.title": "Ćwiczenie: dowolny znak",
  "examples.dotCharacter.description": "Napisz wyrażenie, tak aby dopasować w tekście pojedyncze litery, cyfry, spacje i znaki specjalne. Wyrażenie, które wpiszesz, musi pasować do dowolnego znaku.",

  "examples.characterSet.title": "Ćwiczenie: zbiór znaków",
  "examples.characterSet.description": "Napisz wyrażenie, które dopasuje każde słowo w tekście. Jedne co się zmienia w poniższych słowach to początkowe litery.",

  "examples.negatedCharacterSet.title": "Ćwiczenie: negacja zbioru znaków",
  "examples.negatedCharacterSet.description": "Napisz wyrażenie, które w poniższym tekście będzie pasować do wszystkiego, oprócz słów `beor` i `beur`. Użyj negacji zbioru znaków.",

  "examples.range.title": "Ćwiczenie: zakres liter",
  "examples.range.description": "Napisz wyrażenie, które w poniższym tekście będzie dopasowywać litery od `g` do `k`.\\n\\nLitery `g` i `k` powinny również być uwzględnione w tym dopasowaniu.",

  "examples.rangeNumber.title": "Ćwiczenie: zakres cyfr",
  "examples.rangeNumber.description": "Napisz wyrażenie, które w poniższym tekście będzie dopasowywać cyfry od `2` do `7`.\\n\\Cyfry `2` i `7` powinny również być uwzględnione w tym dopasowaniu.",

  "steps.repetitions.title": "Powtórzenia",
  "steps.repetitions.description": "Niektóre specjalne znaki służą do określenia ile razy dany znak może powtórzyć się w tekście. Te specjalne znaki to plus `+`, gwiazdka `*` i znak zapytania `?`.",

  "steps.asterisk.title": "Gwiazdka `*`",
  "steps.asterisk.description": "Aby wskazać, że dany znak może się nie pojawić wcale lub może się pojawić wiele razy, umieszczamy po nim gwiazdkę `*`. Na przykład, możemy wskazać, że litera `e` nie powinna występować w tekście, może wystąpić raz lub więcej razy obok siebie.",

  "steps.plusCharacter.title": "Plus `+`",
  "steps.plusCharacter.description": "Aby wskazać, że dany znak może wystąpić jeden lub więcej razy, umieszczamy po nim znak plusa `+`. Na przykład, możemy wskazać, że litera `e` może wystąpić w tekście jeden lub więcej razy obok siebie.",

  "steps.questionMark.title": "Znak zapytania `?`",
  "steps.questionMark.description": "Aby wskazać, że dany znak jest opcjonalny, umieszczamy po nim znak zapytania `?`. Na przykład, możemy wskazać, że następna litera `u` jest opcjonalna.",

  "steps.quantifier.title": "Nawiasy klamrowe - 1",
  "steps.quantifier.description": "Aby określić liczbę wystąpień po sobie danego znaku, umieszczamy po nim nawiasy klamrowe `{n}` razem z liczbą określającą, ile razy ma się pojawić. Na przykład, możemy wskazać, że następna litera `e` może wystąpić obok siebie dokładnie `2` razy.",

  "steps.quantifierMin.title": "Nawiasy klamrowe - 2",
  "steps.quantifierMin.description": "Aby określić minimalną liczbę wystąpień po sobie danego znaku, wskazujemy przynajmniej ile razy ma się on pojawić, następnie przecinek `,` i umieszczamy to w nawiasach klamrowych `{n, }`. Na przykład, możemy wskazać, że litera `e` może wystąpić obok siebie przynajmniej `3` razy.",

  "steps.quantifierRange.title": "Nawiasy klamrowe - 3",
  "steps.quantifierRange.description": "Aby określić liczbę wystąpień znaku po sobie danego znaku w określonym zakresie, stosujemy nawiasy klamrowe `{x,y}` z podanym zakresem powtórzeń, który nas interesuje. Na przykład, możemy wskazać, że litera `e` może wystąpić po sobie tylko od `1` do `3` razy.",

  "examples.asterisk.title": "Practice: Asterisk `*`",
  "examples.asterisk.description": "Use the asterisk `*` to write the expression that will select each word, suitable for the absence of the letter `e` in the text and the presence of one or more.",

  "examples.plusCharacter.title": "Practice: Plus Sign `+`",
  "examples.plusCharacter.description": "Write the expression using the plus sign `+` to select words in which the letter `e` occurs one or more times in the text.",

  "examples.questionMark.title": "Practice: Question Mark `?`",
  "examples.questionMark.description": "Write the expression indicating that the letter `n` is optional in the text, using the question mark `?`. Thus, both the words `a` and `an` can be selected.",

  "examples.quantifier.title": "Practice: Curly Braces - 1",
  "examples.quantifier.description": "Write the expression using curly braces `{}` that will find texts containing `4` numbers side by side. Remember that the range `[0-9]` will match a single digit.",

  "examples.quantifierMin.title": "Practice: Curly Braces - 2",
  "examples.quantifierMin.description": "Write the expression using curly braces `{}` that will find texts containing at least `2` numbers side by side.",

  "examples.quantifierRange.title": "Practice: Curly Braces - 3",
  "examples.quantifierRange.description": "Write the expression using curly braces `{}` that will find texts containing at least `1` and at most `4` numbers side by side.",

  "steps.grouping.title": "Parentheses `( )`: Grouping",
  "steps.grouping.description": "We can group an expression and use these groups to reference or enforce some rules. To group an expression, we enclose `()` in parentheses. For now just group `haa` below.",

  "steps.groupReference.title": "Referencing a Group",
  "steps.groupReference.description": "The words `ha` and `haa` are grouped below. The first group is used by writing `\\1` to avoid rewriting. Here `1` denotes the order of grouping. Type `\\2` at the end of the expression to refer to the second group.",

  "steps.nonCapturingGrouping.title": "Parentheses `(?: )`: Non-capturing Grouping",
  "steps.nonCapturingGrouping.description": "You can group an expression and ensure that it is not captured by references. For example, below are two groups. However, the first group reference we denote with `\\1` actually indicates the second group, as the first is a non-capturing group.",

  "steps.pipeCharacter.title": "Pipe Character `|`",
  "steps.pipeCharacter.description": "It allows to specify that an expression can be in different expressions. Thus, all possible statements are written separated by the pipe sign `|`. This differs from charset `[abc]`, charsets operate at the character level. Alternatives are at the expression level. For example, the following expression would select both `cat` and `rat`. Add another pipe sign `|` to the end of the expression and type `dog` so that all words are selected.",

  "steps.escapeCharacter.title": "Escape Character `\\`",
  "steps.escapeCharacter.description": "There are special characters that we use when writing regex. `{ } [ ] / \\ + * . $^ | ?` Before we can select these characters themselves, we need to use an escape character `\\`. For example, to select the dot `.` and asterisk `*` characters in the text, let's add an escape character `\\` before it.",

  "steps.caret.title": "Caret Sign `^`:\\nSelecting by Line Start",
  "steps.caret.description": "We were using `[0-9]` to find numbers. To find only numbers at the beginning of a line, prefix this expression with the `^` sign.",

  "steps.dollar.title": "Dollar Sign `$`:\\nSelecting by End of Line",
  "steps.dollar.description": "Let's use the `$` sign after the `html` value to find the `html` texts only at the end of the line.",

  "steps.wordCharacter.title": "Word Character `\\w`: Letter, Number and Underscore",
  "steps.wordCharacter.description": "The expression `\\w` is used to find letters, numbers and underscore characters. Let's use the expression `\\w` to find word characters in the text.",

  "steps.withoutWordCharacter.title": "Except Word Character `\\W`",
  "steps.withoutWordCharacter.description": "The expression `\\W` is used to find characters other than letters, numbers, and underscores.",

  "steps.numberCharacter.title": "Number Character `\\d`",
  "steps.numberCharacter.description": "`\\d` is used to find only number characters.",

  "steps.withoutNumberCharacter.title": "Except Number Character `\\D`",
  "steps.withoutNumberCharacter.description": "`\\D` is used to find non-numeric characters.",

  "steps.spaceCharacter.title": "Space Character `\\s`",
  "steps.spaceCharacter.description": "`\\s` is used to find only space characters.",

  "steps.withoutSpaceCharacter.title": "Except Space Character `\\S`",
  "steps.withoutSpaceCharacter.description": "`\\S` is used to find non-space characters.",

  "steps.lookarounds.title": "Lookarounds",
  "steps.lookarounds.description": "If we want the phrase we're writing to come before or after another phrase, we need to \"lookaround\". Take the next step to learn how to \"lookaround\".",

  "steps.positiveLookahead.title": "Positive Lookahead: `(?=)`",
  "steps.positiveLookahead.description": "For example, we want to select the hour value in the text. Therefore, to select only the numerical values that have `PM` after them, we need to write the positive look-ahead expression `(?=)` after our expression. Include `PM` after the `=` sign inside the parentheses.",

  "steps.negativeLookahead.title": "Negative Lookahead: `(?!)`",
  "steps.negativeLookahead.description": "For example, we want to select numbers other than the hour value in the text. Therefore, we need to write the negative look-ahead `(?!)` expression after our expression to select only the numerical values that do not have `PM` after them. Include `PM` after the `!` sign inside the parentheses.",

  "steps.positiveLookbehind.title": "Positive Lookbehind: `(?<=)`",
  "steps.positiveLookbehind.description": "For example, we want to select the price value in the text. Therefore, to select only the number values that are preceded by `$`, we need to write the positive lookbehind expression `(?<=)` before our expression. Add `\\$` after the `=` sign inside the parenthesis.",

  "steps.negativeLookbehind.title": "Negative Lookbehind: `(?&lt;!)`",
  "steps.negativeLookbehind.description": "For example, we want to select numbers in the text other than the price value. Therefore, to select only numeric values that are not preceded by `$`, we need to write the negative lookbehind `(?&lt;!)` before our expression. Add `\\$` after the `!` inside the parenthesis.",

  "steps.flags.title": "Flags",
  "steps.flags.description": "Flags change the output of the expression. That's why flags are also called `modifiers`. Flags determine whether the typed expression treats text as separate lines, is case sensitive, or finds all matches. Continue to the next step to learn the flags.",

  "steps.flagsGlobal.title": "Global Flag",
  "steps.flagsGlobal.description": "The `global` flag causes the expression to select all matches. If not used it will only select the first match. Now enable the `global` flag to be able to select all matches.",

  "steps.flagsMultiline.title": "Multiline Flag",
  "steps.flagsMultiline.description": "Regex sees all text as one line. But we use the `multiline` flag to handle each line separately. In this way, the expressions we write to identify patterns at the end of lines work separately for each line. Now enable the `multiline` flag to find all matches.",

  "steps.flagsCaseInsensitive.title": "Case-insensitive Flag",
  "steps.flagsCaseInsensitive.description": "In order to remove the case-sensitivity of the expression we have written, we must activate the `case-insensitive` flag.",

  "steps.greedyMatching.title": "Greedy Matching",
  "steps.greedyMatching.description": "Regex does a greedy match by default. This means that the matchmaking will be as long as possible. Check out the example below. It refers to any match that ends in `r` and can be any character preceded by it. But it does not stop at the first letter `r`.",

  "steps.lazyMatching.title": "Lazy Matching",
  "steps.lazyMatching.description": "Lazy matchmaking, unlike greedy matching, stops at the first matching. For example, in the example below, add a `?` after `*` to find the first match that ends with the letter `r` and is preceded by any character. It means that this match will stop at the first letter `r`.",

  "steps.completeAllSteps.title": "Congratulations, you have completed all the steps!",
  "steps.completeAllSteps.description": "You can return to the previous steps whenever you want, and you can easily navigate through all the steps you have passed."
}
